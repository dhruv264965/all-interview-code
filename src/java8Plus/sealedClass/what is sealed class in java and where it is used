A sealed class in Java is a class that restricts which other classes or interfaces may extend or implement it.
This feature was introduced in Java 15 as a preview and became a standard feature in Java 17.
public sealed class Vehicle permits Car, Bike {
}
final class Car extends Vehicle {  // no one can extend
}
non-sealed class Bike extends Vehicle { // other class can extend
}

sealed â†’ Declares the base class as sealed.
permits â†’ Specifies which classes are allowed to extend it.
All permitted subclasses must be in the same module (or same package if no module system).

 Why Use Sealed Classes?
âœ… To control inheritance and prevent unwanted extension.
âœ… Enforce domain modeling rules (like an enum but more flexible).
âœ… Improve exhaustiveness checking in switch statements.


ğŸ“ Where It Is Used?
ğŸ” 1. Security-Sensitive APIs
Restrict who can extend your critical base classes.

ğŸ§  2. Domain Modeling
E.g., represent different types of payments:
public sealed interface Payment permits CreditCard, UPI, Cash {}

public final class CreditCard implements Payment {}
public final class UPI implements Payment {}
public final class Cash implements Payment {}
Now you can do:
switch (payment) {
    case CreditCard c -> processCard(c);
    case UPI u -> processUPI(u);
    case Cash ca -> processCash(ca);
}
ğŸ” 3. Exhaustive switch with records + pattern matching
Used with record types and pattern matching to make code more type-safe.

| Type         | Extensible? | Restriction                              |
| ------------ | ----------- | ---------------------------------------- |
| `final`      | âŒ No        | Cannot be subclassed                     |
| `abstract`   | âœ… Yes       | Can be subclassed freely                 |
| `sealed`     | âœ… Limited   | Only allowed types via `permits`         |
| `non-sealed` | âœ… Yes       | Removes restriction from a sealed parent |

â€œSealed classes in Java allow us to tightly control the class hierarchy. Itâ€™s especially useful in domain-driven design
where we want to define a closed set of subclassesâ€”like different types of payment methods, user roles, or shapes.
 It also helps the compiler perform better exhaustiveness checks in switch statements.â€


