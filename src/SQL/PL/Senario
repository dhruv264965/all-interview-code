there are one senarion where first we storing mobile number and datatype is number 10 and now i want for all number
we should add +91 and store data .. what i cant to do . i need to create backup table and put new data type for mobile number
as varchar(20) and insert all the data into that class with update the value +91 .

Answer->
Problem recap (in simple words)

Old table: mobile_number stored as NUMBER(10)

You now want:

Country code +91 added to all existing numbers

New datatype VARCHAR2(20) (because +91 is text)

Best approach:
‚úÖ Create a backup/new table
‚úÖ Convert + transform data during insert

Step 1Ô∏è‚É£ Old table (example)
employee
--------------------------
id            NUMBER
name          VARCHAR2(50)
mobile_no     NUMBER(10)

Step 2Ô∏è‚É£ Create backup / new table with VARCHAR2
CREATE TABLE employee_bkp (
    id        NUMBER,
    name      VARCHAR2(50),
    mobile_no VARCHAR2(20)
);

Step 3Ô∏è‚É£ Insert data with +91 added

üëâ Convert NUMBER ‚Üí VARCHAR2 and concatenate +91

INSERT INTO employee_bkp (id, name, mobile_no)
SELECT id,
       name,
       '+91' || TO_CHAR(mobile_no)
FROM employee;


‚úî TO_CHAR converts number to text
‚úî || concatenates strings
‚úî +91 is safely stored

Step 4Ô∏è‚É£ (Optional) Use PL/SQL block
BEGIN
    INSERT INTO employee_bkp (id, name, mobile_no)
    SELECT id,
           name,
           '+91' || TO_CHAR(mobile_no)
    FROM employee;

    COMMIT;
END;
/

Step 5Ô∏è‚É£ Verify result
SELECT mobile_no FROM employee_bkp;


Result:

+919876543210
+919123456789

üî• Important Notes (very important in interviews)

‚ùå Phone numbers should NOT be NUMBER

Leading zeros lost

Country codes impossible

‚úÖ Always use VARCHAR2

Migration via INSERT‚Ä¶SELECT is safest

Optional: Replace old table (after validation)
RENAME employee TO employee_old;
RENAME employee_bkp TO employee;

Summary

‚úî Create new table
‚úî Change datatype
‚úî Transform data during insert
‚úî No data loss

---------------------------------------------------------------------------------------------
How to update in same table (if allowed)
 How to add CHECK constraint for mobile format
  How to handle NULL or invalid numbers

  answer->

  1Ô∏è‚É£ Update in the SAME table (if allowed)
  Step 1: Change datatype NUMBER ‚Üí VARCHAR2

  You must modify the column first.

  ALTER TABLE employee
  MODIFY mobile_no VARCHAR2(20);

  Step 2: Update existing values with +91
  UPDATE employee
  SET mobile_no = '+91' || mobile_no
  WHERE mobile_no IS NOT NULL;

  COMMIT;


  ‚úî Works because column is now VARCHAR
  ‚úî NULLs are untouched

  ‚ö†Ô∏è Important safety check before update
  SELECT mobile_no
  FROM employee
  WHERE LENGTH(TO_CHAR(mobile_no)) <> 10;


  This helps find invalid mobile numbers before updating.

  2Ô∏è‚É£ Add CHECK constraint for mobile number format
  Indian mobile format

  Starts with +91

  Followed by 10 digits

  Total length = 13

  Add CHECK constraint
  ALTER TABLE employee
  ADD CONSTRAINT chk_mobile_format
  CHECK (
      REGEXP_LIKE(mobile_no, '^\+91[0-9]{10}$')
  );


  ‚úî Ensures format like: +919876543210
  ‚úî Blocks invalid inserts/updates

  3Ô∏è‚É£ Handle NULL or invalid numbers
  ‚úÖ Case A: Allow NULL mobile numbers

  Just modify constraint:

  ALTER TABLE employee
  ADD CONSTRAINT chk_mobile_format
  CHECK (
      mobile_no IS NULL
      OR REGEXP_LIKE(mobile_no, '^\+91[0-9]{10}$')
  );


  ‚úî NULL allowed
  ‚úî Non-NULL must be valid

  ‚ùå Case B: Find invalid data before adding constraint
  SELECT id, mobile_no
  FROM employee
  WHERE mobile_no IS NOT NULL
  AND NOT REGEXP_LIKE(mobile_no, '^\+91[0-9]{10}$');


  Fix these rows before adding the constraint.

  üîß Case C: Auto-fix invalid numbers (example logic)
  UPDATE employee
  SET mobile_no = NULL
  WHERE mobile_no IS NOT NULL
  AND NOT REGEXP_LIKE(mobile_no, '^\+91[0-9]{10}$');

  COMMIT;

  üö´ Case D: Prevent future bad data (trigger ‚Äì optional)
  CREATE OR REPLACE TRIGGER trg_mobile_check
  BEFORE INSERT OR UPDATE ON employee
  FOR EACH ROW
  BEGIN
      IF :NEW.mobile_no IS NOT NULL
         AND NOT REGEXP_LIKE(:NEW.mobile_no, '^\+91[0-9]{10}$') THEN
          RAISE_APPLICATION_ERROR(-20001, 'Invalid mobile number format');
      END IF;
  END;
  /

  ‚úÖ Final Best Practice Summary
  Task	Best Solution
  Change datatype	ALTER TABLE MODIFY
  Add +91	UPDATE
  Validate format	CHECK + REGEXP_LIKE
  Allow NULLs	mobile_no IS NULL OR ‚Ä¶
  Prevent bad data	Constraint > Trigger
  Interview gold line ‚ú®

  ‚ÄúPhone numbers should always be stored as VARCHAR, not NUMBER.‚Äù


  -----------------------------------------------------------------------------------------------------
  Formatting for multiple country codes

  Masking mobile numbers

  Performance impact of REGEXP constraints

  Real-world validation strategy used in banks


  Answer->
  1Ô∏è‚É£ Support MULTIPLE country codes (not just +91)
  Rule

  Starts with +

  Country code: 1‚Äì3 digits

  Mobile number: 8‚Äì12 digits (varies by country)

  CHECK constraint (generic & flexible)
  ALTER TABLE employee
  ADD CONSTRAINT chk_mobile_international
  CHECK (
      mobile_no IS NULL
      OR REGEXP_LIKE(mobile_no, '^\+[0-9]{1,3}[0-9]{8,12}$')
  );


  ‚úî Examples allowed:

  +919876543210
  +14155552671
  +447911123456

  2Ô∏è‚É£ Mask mobile numbers (security / privacy)
  Show only last 4 digits
  SELECT
      RPAD('*', LENGTH(mobile_no) - 4, '*') || SUBSTR(mobile_no, -4) AS masked_mobile
  FROM employee;


  Example output:

  **********3210

  3Ô∏è‚É£ Performance: REGEXP vs LENGTH (important!)
  REGEXP (slower but flexible)

  ‚úî Best for validation
  ‚ùå Slightly slower on huge tables

  Faster alternative (when only +91)
  CHECK (
      mobile_no IS NULL
      OR (SUBSTR(mobile_no, 1, 3) = '+91'
          AND LENGTH(mobile_no) = 13
          AND TRANSLATE(mobile_no, '+0123456789', '+') IS NULL)
  );


  üî• This avoids REGEXP and is faster.

  4Ô∏è‚É£ Real-world validation strategy (bank / telecom style)
  What professionals actually do:

  Store as VARCHAR2

  CHECK constraint ‚Üí basic format

  Trigger or application logic ‚Üí deeper validation

  No COMMIT in triggers

  Never store phone as NUMBER

  Recommended combo
  ALTER TABLE employee
  ADD CONSTRAINT chk_mobile_basic
  CHECK (
      mobile_no IS NULL
      OR REGEXP_LIKE(mobile_no, '^\+[0-9]{10,15}$')
  );


  Application layer handles:

  Country-specific rules

  OTP verification

  Duplicates

  üéØ Final Architecture (Interview-ready)
  TABLE
   ‚îî‚îÄ‚îÄ VARCHAR2 mobile_no
         ‚îú‚îÄ‚îÄ CHECK constraint (format)
         ‚îú‚îÄ‚îÄ Indexed (optional)
         ‚îî‚îÄ‚îÄ Validated at app level

  One-liner interview answer üí°

  ‚ÄúMobile numbers are stored as VARCHAR2 with international format, validated using CHECK constraints and application-level logic.‚Äù

  ----------------------------------------------------------------
  How to index mobile numbers

  How to prevent duplicates

  How to normalize phone numbers

  How to rollback safely if update fails

  Answer->
  1Ô∏è‚É£ How to INDEX mobile numbers
  Why index mobile numbers?

  Fast lookup during:

  Login / OTP

  Customer search

  Dedup checks

  Basic index
  CREATE INDEX idx_employee_mobile
  ON employee (mobile_no);


  ‚úî Speeds up WHERE mobile_no = '+919876543210'

  Function-based index (normalized search)

  If you normalize by removing spaces/dashes:

  CREATE INDEX idx_emp_mobile_norm
  ON employee (
      REGEXP_REPLACE(mobile_no, '[^0-9]', '')
  );


  Now this query uses the index:

  SELECT *
  FROM employee
  WHERE REGEXP_REPLACE(mobile_no, '[^0-9]', '') =
        '919876543210';

  2Ô∏è‚É£ How to PREVENT duplicates
  Option A: UNIQUE constraint (best)
  ALTER TABLE employee
  ADD CONSTRAINT uq_employee_mobile UNIQUE (mobile_no);


  ‚úî Database-level guarantee
  ‚úî Fast & safe
  ‚úî Handles concurrency

  Option B: Unique on normalized value (real-world best)

  Prevents:

  +91 9876543210
  +91-9876543210
  +919876543210

  CREATE UNIQUE INDEX uq_emp_mobile_norm
  ON employee (
      REGEXP_REPLACE(mobile_no, '[^0-9]', '')
  );


  üî• This is production-grade.

  3Ô∏è‚É£ How to NORMALIZE phone numbers
  What normalization means

  Store phone numbers in one consistent format:

  +<countrycode><number>

  Normalize existing data
  UPDATE employee
  SET mobile_no =
      '+' || REGEXP_REPLACE(mobile_no, '[^0-9]', '')
  WHERE mobile_no IS NOT NULL;


  Example:

  (987) 654-3210  ‚Üí  +9876543210

  Normalize future inserts (trigger)
  CREATE OR REPLACE TRIGGER trg_mobile_normalize
  BEFORE INSERT OR UPDATE ON employee
  FOR EACH ROW
  BEGIN
      IF :NEW.mobile_no IS NOT NULL THEN
          :NEW.mobile_no :=
              '+' || REGEXP_REPLACE(:NEW.mobile_no, '[^0-9]', '');
      END IF;
  END;
  /


  ‚úî Keeps data clean automatically
  ‚úî No application dependency

  4Ô∏è‚É£ How to ROLLBACK safely if update fails

  This is critical in production.

  AÔ∏è‚É£ Use SAVEPOINT (best practice)
  BEGIN
      SAVEPOINT before_mobile_update;

      UPDATE employee
      SET mobile_no = '+91' || mobile_no
      WHERE mobile_no IS NOT NULL;

      COMMIT;
  EXCEPTION
      WHEN OTHERS THEN
          ROLLBACK TO before_mobile_update;
          DBMS_OUTPUT.PUT_LINE('Update failed: ' || SQLERRM);
  END;
  /


  ‚úî Partial rollback
  ‚úî Table remains consistent

  BÔ∏è‚É£ Dry-run validation before update
  SELECT COUNT(*)
  FROM employee
  WHERE mobile_no IS NOT NULL
  AND LENGTH(mobile_no) <> 10;


  Fix errors before touching data.

  CÔ∏è‚É£ Always BACKUP before mass update
  CREATE TABLE employee_backup AS
  SELECT * FROM employee;


  üî• This is non-negotiable in real systems.

  DÔ∏è‚É£ Never COMMIT inside loops

  Bad ‚ùå

  FOR r IN (SELECT * FROM employee) LOOP
      UPDATE employee SET ...
      COMMIT;
  END LOOP;


  Good ‚úÖ

  UPDATE employee SET ...
  COMMIT;

  üß† Final Professional Strategy
  1. Backup table
  2. Normalize existing data
  3. Add CHECK constraint
  4. Add UNIQUE index
  5. Add search index
  6. Use SAVEPOINT for safety

  Interview Power Answer üöÄ

  ‚ÄúWe normalize mobile numbers, enforce uniqueness with a function-based unique index, validate format via CHECK
  constraints, index for fast lookup, and use savepoints for safe rollback during migrations.‚Äù