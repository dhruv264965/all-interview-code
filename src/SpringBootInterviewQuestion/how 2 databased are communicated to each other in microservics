â€œIn microservices, we follow the Database per Service principle. So, we never directly connect to
another service's database.

If Service A needs data from Service B, it communicates through a REST API or uses asynchronous messaging
 via Kafka or RabbitMQ. This way, each service stays loosely coupled, independently scalable, and resilient.â€

Scenario:
Microservice A: CustomerService with its own DB
Microservice B: InvoiceService with its own DB
If InvoiceService needs customer details:
âŒ Donâ€™t join DBs or connect to CustomerService DB directly
âœ… Instead:
Call: GET /customers/{id} on CustomerService
Or subscribe to CustomerCreated Kafka event and cache minimal info

âœ… Right Ways to Communicate Between Microservices (and Their Databases):
1. REST API (Synchronous Communication)
Each microservice exposes APIs. If one service needs data from another, it calls the other service's API.
ğŸ” Example:
Order Service needs user info â†’ It calls User Service:
GET http://user-service/api/users/123
Result: Order Service gets data from User DB indirectly via API.
2. Kafka / RabbitMQ (Asynchronous)
Services publish events when data changes. Other services listen and update their own database.
 Example:
User Service publishes UserCreated event
Order Service listens and stores a copy of the user data it needs
This is called event-driven architecture.

diagram-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          A. âœ… Synchronous Communication via REST API
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          +-------------------+             HTTP Request           +-------------------+
          |  Service A        |  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ |  Service B        |
          | (Order Service)   |                                     | (User Service)    |
          |                   | â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  HTTP Response â”€â”€â”€â”€â”€ |                   |
          +-------------------+                                     +-------------------+
          | DB A              |                                     | DB B              |
          +-------------------+                                     +-------------------+

          â†’ Order Service calls User Service API to fetch data in real-time.
          â†’ Tight timing dependency (A waits for B).


          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          B. âœ… Asynchronous Communication via Kafka
          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

          +-------------------+                                     +-------------------+
          |  Service A        |                                     |  Service B        |
          | (User Service)    |                                     | (Order Service)   |
          |                   |                                     |                   |
          | on user created:  |                                     | Kafka Listener    |
          | â–¶ Kafka Producer â”€â”¼â”€â”€â”€â”€â”€â–º  Kafka Topic: user-events â”€â”€â”€â–¶| on UserCreated    |
          +-------------------+                                     +-------------------+
          | DB A              |                                     | DB B              |
          +-------------------+                                     +-------------------+

          â†’ User Service publishes a message like "UserCreated".
          â†’ Order Service listens to the event and updates its own DB.
          â†’ Fully decoupled, highly scalable, no waiting.

---------------------------------------------------------------------------------------
example to show 2 db communicate to each other

ğŸ“˜ Scenario:
UserService â†’ Has its own DB â†’ Publishes a UserCreated event

OrderService â†’ Has its own DB â†’ Listens for UserCreated and stores minimal user info it needs

âœ… Tools:
Spring Boot

Spring Kafka

Spring Data JPA

MySQL/PostgreSQL (for DB)

ğŸ” Architecture:

          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              Kafka Topic               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚  UserService â”‚ â”€â”€â”€â”€â”€â–º  topic: user-events  â”€â”€â”€â”€â”€â–º    â”‚ OrderService â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â–² DB: User                                               â–² DB: Order + UserRef
1ï¸âƒ£ UserService â€“ Publishes to Kafka on user creation
ğŸ“¦ Entity

@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String email;
}
ğŸš€ REST Controller

@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired private UserRepository userRepo;
    @Autowired private KafkaTemplate<String, String> kafkaTemplate;
    private final ObjectMapper mapper = new ObjectMapper();

    @PostMapping
    public ResponseEntity<?> createUser(@RequestBody User user) throws JsonProcessingException {
        User savedUser = userRepo.save(user);

        // Publish event
        String userEvent = mapper.writeValueAsString(savedUser);
        kafkaTemplate.send("user-events", userEvent);

        return ResponseEntity.ok("User created and event sent");
    }
}
2ï¸âƒ£ OrderService â€“ Consumes Kafka event and updates its own DB
ğŸ“¦ UserRef Entity (only stores partial user info)

@Entity
public class UserRef {
    @Id
    private Long id;
    private String name;
    private String email;
}
ğŸ› ï¸ Kafka Consumer in OrderService

@Service
public class UserEventConsumer {

    @Autowired private UserRefRepository userRefRepo;
    private final ObjectMapper mapper = new ObjectMapper();

    @KafkaListener(topics = "user-events", groupId = "order-service")
    public void consume(String message) throws JsonProcessingException {
        UserRef user = mapper.readValue(message, UserRef.class);
        userRefRepo.save(user);
        System.out.println("âœ… User info saved in OrderService DB: " + user.getName());
    }
}
ğŸ§  Summary (For Interview):
"In a microservices setup, I avoid direct DB calls across services. Instead, I publish domain events (like UserCreated)
 to Kafka.

The OrderService listens to these events and stores the necessary user info in its own DB. This ensures data
separation, loose coupling, and scalable async communication."

