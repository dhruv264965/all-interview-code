When dealing with a large dataset, optimizing your Spring Boot CRUD API is crucial for performance,
scalability, and efficiency. Below are the best practices to optimize your API.

1ï¸âƒ£ Use Pagination & Sorting (Avoid Fetching All Data)
âŒ Bad Practice:
Fetching all records at once leads to high memory usage and slow responses.

âœ… Solution:
Use pagination with Pageable to fetch data in chunks.

ğŸ“Œ Example: Paginated API
Controller

@GetMapping
public ResponseEntity<Page<EmployeeDTO>> getAllEmployees(
    @RequestParam(defaultValue = "0") int page,
    @RequestParam(defaultValue = "10") int size,
    @RequestParam(defaultValue = "id") String sortBy,
    @RequestParam(defaultValue = "asc") String order) {

    Sort sort = order.equalsIgnoreCase("desc") ? Sort.by(sortBy).descending() : Sort.by(sortBy).ascending();
    Pageable pageable = PageRequest.of(page, size, sort);
    Page<EmployeeDTO> employees = employeeService.getAllEmployees(pageable);
    return ResponseEntity.ok(employees);
}
âœ” Prevents memory overload
âœ” Improves response time
âœ” Supports sorting dynamically

2ï¸âƒ£ Use DTOs Instead of Entities
Returning JPA entities directly exposes unnecessary data and can lead to performance issues.

âœ… Solution:
Use DTOs (Data Transfer Objects) to send only required fields.

ğŸ“Œ Example: DTO Conversion
DTO Class

@Data
public class EmployeeDTO {
    private String name;
    private double salary;
}
Convert Entity to DTO

public EmployeeDTO toDTO(Employee employee) {
    return new EmployeeDTO(employee.getName(), employee.getSalary());
}
âœ” Reduces payload size
âœ” Improves API security

3ï¸âƒ£ Use Indexing in the Database
For large datasets, queries should be optimized using indexes.

âœ… Solution:
Use indexes for frequently queried fields.

ğŸ“Œ Example: Adding Index

@Entity
@Table(name = "employees", indexes = {
    @Index(name = "idx_employee_name", columnList = "name"),
    @Index(name = "idx_employee_salary", columnList = "salary")
})
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private double salary;
}
âœ” Speeds up search queries
âœ” Improves performance in large datasets

4ï¸âƒ£ Use @Query with LIMIT for Large Data Queries
âŒ Bad Practice:
Fetching all records without limiting results.

âœ… Solution:
Use @Query with LIMIT to retrieve only the required number of records.

ğŸ“Œ Example: Fetching Top 10 Employees by Salary

@Query("SELECT e FROM Employee e ORDER BY e.salary DESC")
List<Employee> findTop10HighestSalaries(Pageable pageable);
âœ” Reduces database load
âœ” Improves API speed

5ï¸âƒ£ Enable Lazy Loading for Large Relationships
âŒ Bad Practice:
Using EAGER fetching loads unnecessary related entities.

âœ… Solution:
Use LAZY loading for OneToMany, ManyToMany relationships.

ğŸ“Œ Example: Lazy Loading

@Entity
public class Department {
    @OneToMany(mappedBy = "department", fetch = FetchType.LAZY)
    private List<Employee> employees;
}
âœ” Prevents excessive data loading
âœ” Improves API performance

6ï¸âƒ£ Use Caching to Reduce Database Calls
For frequently accessed data, use caching instead of making repeated database queries.

âœ… Solution:
Use Spring Cache or Redis for caching.

ğŸ“Œ Example: Using Spring Cache
Enable Caching

@EnableCaching
@SpringBootApplication
public class EmployeeApplication {
}
Cache API Responses

@Cacheable(value = "employees", key = "#id")
public EmployeeDTO getEmployeeById(Long id) {
    return employeeRepository.findById(id).map(this::toDTO).orElse(null);
}
âœ” Reduces database load
âœ” Improves API response time

7ï¸âƒ£ Use Batch Processing for Bulk Inserts/Updates
If your API handles bulk inserts or updates, avoid single row operations.

âœ… Solution:
Use Spring Data JPA saveAll() or JDBC Batch Processing.

ğŸ“Œ Example: Bulk Insert Using saveAll()

public List<Employee> saveEmployees(List<Employee> employees) {
    return employeeRepository.saveAll(employees);
}
âœ” Improves write performance
âœ” Reduces transaction overhead

8ï¸âƒ£ Optimize Queries Using Specifications (JpaSpecificationExecutor)
For dynamic filtering + complex queries, use JpaSpecificationExecutor.

ğŸ“Œ Example: Filtering Employees with Dynamic Criteria
\
public class EmployeeSpecification {
    public static Specification<Employee> hasSalaryGreaterThan(double salary) {
        return (root, query, cb) -> cb.greaterThan(root.get("salary"), salary);
    }
}
âœ” Optimizes database queries dynamically
âœ” Useful for API search filters

9ï¸âƒ£ Use Asynchronous Processing for Heavy Operations
For time-consuming operations, use @Async to avoid blocking API requests.

ğŸ“Œ Example: Asynchronous API Call
java
Copy
Edit
@Async
public CompletableFuture<List<Employee>> fetchLargeEmployeeData() {
    List<Employee> employees = employeeRepository.findAll();
    return CompletableFuture.completedFuture(employees);
}
âœ” Non-blocking API calls
âœ” Improves request handling performance

ğŸ”Ÿ Use Connection Pooling for Database Connections
Using HikariCP (default connection pool in Spring Boot) ensures efficient database connections.

ğŸ“Œ Configure HikariCP in application.properties
properties
Copy
Edit
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
âœ” Prevents DB connection exhaustion
âœ” Optimizes concurrent requests

ğŸ¯ Summary: Best Practices for Large Datasets
Optimization	Benefit
Use Pagination & Sorting	Prevents loading all records at once
Use DTOs Instead of Entities	Reduces API payload size
Use Indexing in DB	Improves query performance
Use @Query with LIMIT	Fetches only required data
Enable Lazy Loading	Avoids unnecessary data fetching
Use Caching (@Cacheable)	Reduces repeated DB queries
Use Batch Processing (saveAll)	Optimizes bulk inserts/updates
Use JpaSpecificationExecutor	Efficient for dynamic filtering
Use @Async for Heavy Operations	Prevents API blocking
Use Connection Pooling (HikariCP)	Efficient DB connections
