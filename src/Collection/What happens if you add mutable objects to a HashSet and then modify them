 â€œIf you add a mutable object to a HashSet, and then mutate it in a way that affects equals() or hashCode(),
 the set can no longer find or remove that object correctly. This breaks the expected behavior of the set and
  can lead to duplicates. Thatâ€™s why itâ€™s recommended to use immutable objects as elements in a HashSet.â€

  You break the contract of hashCode() and equals() â€” and this can lead to:
  âŒ Inability to find, remove, or detect duplicates correctly
  âŒ The object becoming "invisible" to the HashSet
  âŒ Violations of set behavior (e.g., duplicate entries)

  ğŸ” Why does this happen?
  HashSet uses a HashMap internally, which:
  Stores elements based on their hash code (bucket location)
  Uses equals() to detect duplicates
  If you change the fields of the object after adding it, and those fields affect hashCode() or equals(), then:
  Its hashCode changes, so:
  Itâ€™s now in the â€œwrongâ€ bucket
  The HashSet canâ€™t find it anymore for operations like contains() or remove()

  class Person {
      String name;

      Person(String name) {
          this.name = name;
      }

      @Override
      public int hashCode() {
          return name.hashCode();
      }

      @Override
      public boolean equals(Object o) {
          if (this == o) return true;
          if (!(o instanceof Person)) return false;
          Person p = (Person) o;
          return name.equals(p.name);
      }
  }

  public class Main {
      public static void main(String[] args) {
          Set<Person> set = new HashSet<>();
          Person p = new Person("Alice");

          set.add(p);
          System.out.println(set.contains(p)); // true âœ…

          // Now mutate the object
          p.name = "Bob";

          System.out.println(set.contains(p)); // false âŒ
          set.remove(p);                       // fails silently âŒ
          set.add(p);                          // added again âœ…

          System.out.println(set.size());      // 2 âŒ Duplicate!
      }
  }
